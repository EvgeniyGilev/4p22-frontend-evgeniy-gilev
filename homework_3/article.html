<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Пример текста с якорными ссылками</title>
</head>

<body>
    <header>
        <h1>Принципы SOLID (объектно-ориентированное программирование)</h1>
    </header>
    <aside>
        <h3>Содержание</h3>
        <ol>
            <li><a href="#solid">Что такое SOLID?</a></li>
            <li><a href="#s">S - Принцип единственной ответственности</a></li>
            <li><a href="#o">O - Принцип открытости/закрытости</a></li>
            <li><a href="#l">L - Принцип подстановки Лисков</a></li>
            <li><a href="#i">I - Принцип разделения интерфейса</a></li>
            <li><a href="#d">D - Принцип инверсии зависимостей</a></li>
        </ol>
        <br>
        <a href="./index.html">Вернуться на главную страницу</a>
        <br>
    </aside>
    <main>
        <div>
            <h2 id="solid">Что такое SOLID?</h2>
            <p><b>SOLID</b> (сокр. от англ. single responsibility, open–closed, Liskov substitution, interface
                segregation
                и dependency inversion) в программировании — мнемонический акроним, введённый Майклом Фэзерсом
                (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в начале 2000-х,
                которые означали 5 основных принципов объектно-ориентированного программирования и
                проектирования.
            </p>
            <p>При создании программных систем использование принципов SOLID способствует созданию
                такой системы,
                которую будет легко поддерживать и расширять в течение долгого времени. Принципы SOLID — это
                руководства, которые также могут применяться во время работы над существующим программным
                обеспечением для его улучшения, например, для удаления «дурно пахнущего кода».

                Стратегии гибкой и адаптивной разработки предполагают написание кода с соблюдением принципов SOLID.
            </p>
        </div>
        <br>
        <div>
            <h2 id="s">S - Принцип единственной ответственности</h2>
            <p>
                <b>Принцип единственной ответственности</b> (англ. single-responsibility principle, SRP) — принцип ООП,
                обозначающий, что каждый объект должен иметь одну ответственность и эта ответственность должна быть
                полностью инкапсулирована в класс. Все его поведения должны быть направлены исключительно на обеспечение
                этой ответственности.
                Термин SRP был введён Робертом С. Мартином в одноимённой статье как часть SOLID, ставших популярными
                благодаря его книге «Быстрая разработка программ. Принципы, примеры, практика.». Мартин описал SRP,
                основываясь на закономерности, описанной Томом ДеМарко и Мейлиром Пейдж-Джонсом и названной
                связностью.
            </p>
            <p>
                В SOLID — буква «S» является аббревиатурой, которая образована сокращением от английского названия
                принципа
                единственной ответственности(англ. Single Responsibility Principle).
            </p>
            Мартин определяет ответственность как причину изменения и заключает, что классы должны иметь одну и только
            одну причину для изменений. Например, представьте себе класс, который составляет и печатает отчёт. Такой
            класс может измениться по двум причинам:
            <p>
                может измениться само содержимое отчёта
                может измениться формат отчёта.
                Логично, что оба аспекта этих причин на самом деле являются двумя разными ответственностями. SRP
                говорит,
                что в таком случае нужно разделить класс на два новых класса, для которых будет характерна только одна
                ответственность. Причина, почему нужно сохранять направленность классов на единственную цель в том, что
                это
                делает классы более здоровыми. Что касается класса, приведённого выше, если произошло изменение в
                процессе
                составления отчёта — есть большая вероятность, что в негодность придёт код, отвечающий за печать.
            </p>
            <p>
                При разработке различных поведений одного класса часто появляется «Божественный объект», который в ООП
                считается антипаттерном. Соблюдение принципа единственной ответственности позволяет избегать этого
                антипаттерна.
            </p>
        </div>
        <br>
        <div>
            <h2 id="o">O - Принцип открытости/закрытости</h2>
            <p>Принцип открытости/закрытости означает, что программные сущности должны быть:
            </p>
            <ul>
                <li>открыты для расширения: означает, что поведение сущности может быть расширено путём создания новых
                    типов сущностей.</li>
                <li>закрыты для изменения: в результате расширения поведения сущности, не должны вноситься изменения в
                    код, который эту сущность использует.</li>
            </ul>
            <p>Это особенно значимо в производственной среде, когда изменения в исходном коде потребуют проведение
                пересмотра кода, модульного тестирования и других подобных процедур, чтобы
                получить право на использование его в программном продукте. Код, подчиняющийся данному принципу, не
                изменяется при расширении и поэтому не требует таких трудозатрат.
            </p>
            <p>Термин <i>«принцип открытости/закрытости»</i> имеет два значения:
            </p>
            <ul>
                <li>Принцип открытости/закрытости Мейера
                    <p>Идея была в том, что однажды разработанная реализация класса в дальнейшем требует только
                        исправления
                        ошибок, а новые или изменённые функции требуют создания нового класса. Этот новый класс может
                        переиспользовать код исходного класса через механизм наследования. Производный подкласс может
                        реализовывать или не реализовывать интерфейс исходного класса.

                        Определение Мейера поддерживает идею наследования реализации. Реализация может быть
                        переопределена
                        через наследование, но спецификации интерфейса могут измениться. Существующая реализация должна
                        быть
                        закрыта для изменений, но новые реализации не обязаны использовать существующий интерфейс
                    </p>
                </li>

                <li>Полиморфный принцип открытости/закрытости
                    <p>В течение 1990-х принцип открытости/закрытости стал де-факто переопределён для применения с
                        абстрактными интерфейсами, реализации которых могут быть изменены, и могут быть созданы
                        множественные реализации и полиморфно замещены одна на другую.

                        В противоположность применения Мейером, это определение поддерживает идею наследования от
                        абстрактных базовых классов. Спецификации интерфейсов могут быть переиспользованы через
                        наследование, но реализации переиспользовать необязательно. Существующий интерфейс должен быть
                        закрыт для модификаций, а новые реализации должны, по меньшей мере, реализовывать этот
                        интерфейс.
                    </p>
                </li>
            </ul>
            <p>Оба значения используют наследование для решения дилеммы, но цели, способы и результаты — различны.
            </p>
        </div>
        <br>
        <div>
            <h2 id="l">L - Принцип подстановки Лисков</h2>
            <p><b>Принцип подстановки Барбары Лисков</b> (англ. Liskov Substitution Principle, LSP) в
                объектно-ориентированном программировании является специфичным определением подтипа, предложенным
                Барбарой Лисков в 1987 году на конференции в основном докладе под названием Абстракция данных и
                иерархия.
            </p>
            <p>
                В последующей статье[2] Лисков кратко сформулировала свой принцип следующим образом:
            </p>
            <p>
                <i>Пусть <b>q(x)</b> является свойством, верным относительно объектов <b>x</b> некоторого типа <b>T</b>.
                    Тогда <b>q(y)</b> также должно быть верным для объектов <b>y</b> типа <b>S</b>, где <b>S</b>
                    является подтипом типа <b>T.</b>
                </i>
            </p>
            <p>Роберт С. Мартин определил[3] этот принцип так:
            </p>
            <p>
                Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не
                зная об этом.
            </p>
            <p>
                Таким образом, идея Лисков о «подтипе» даёт определение понятия замещения — если S является подтипом T,
                тогда объекты типа T в программе могут быть замещены объектами типа S без каких-либо изменений
                желательных свойств этой программы (например, корректность).
            </p>
            <p>
                Этот принцип является важнейшим критерием для оценки качества принимаемых решений при построении
                иерархий наследования. Сформулировать его можно в виде простого правила: тип S будет подтипом Т тогда и
                только тогда, когда каждому объекту oS типа S соответствует некий объект oT типа T таким образом, что
                для всех программ P, реализованных в терминах T, поведение P не будет меняться, если oT заменить на oS.
            </p>
            <p>
                Более простыми словами можно сказать, что поведение наследующих классов не должно противоречить
                поведению, заданному базовым классом, то есть поведение наследующих классов должно быть ожидаемым для
                кода, использующего переменную базового типа.
            </p>
            <p>
                Саттер и Александреску в своём руководстве по использованию C++ для выражения этого принципа также
                используют фразу «подкласс не должен требовать от вызывающего кода больше, чем базовый класс, и не
                должен предоставлять вызывающему коду меньше, чем базовый класс». По мнению данных авторов, публичное
                наследование в C++ можно употреблять только тогда, когда оно удовлетворяет принципу Лисков. Приватное
                наследование, по их же мнению, дозволено использовать для доступа к protected части базы и перекрытия
                виртуальных методов. В любом же ином случае, то есть для всего лишь повторного использования кода из
                базы, наследование применять нельзя.
            </p>
            <p>
                Основания: использование публичного наследования для повторного использования кода приводит к тому, что
                внешний мир начинает считать класс Derived разновидностью класса Base, и возможно появление кода, явно
                использующего этот факт. Это сильно сужает простор для манёвра архитектора в дальнейшем поддержании и
                рефакторинге класса Derived.
            </p>
        </div>
        <br>
        <div>
            <h2 id="i">I - Принцип разделения интерфейса</h2>
            <p><b>Принцип разделения интерфейса</b> (англ. interface segregation principle, ISP) — один из пяти
                принципов проектирования классов «SOLID» в объектно-ориентированном программировании.
            </p>
            <p><b>Программные сущности не должны зависеть от методов, которые они не используют.</b>
                Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на
                более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о
                методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться
                программные сущности, которые этот метод не используют.</p>
        </div>
        <br>
        <div>
            <h2 id="d">D - Принцип инверсии зависимостей</h2>
            <p><b>Принцип инверсии зависимостей</b> (англ. dependency inversion principle, DIP) — принцип
                объектно-ориентированного программирования, суть которого состоит в том, что классы должны зависеть от
                абстракций, а не от конкретных деталей
            </p>
            <ul>
                <li>A. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны
                    зависеть от абстракций.</li>
                <li>B. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</li>
            </ul>
        </div>
    </main>
    <Footer>
        <div>
            Материал взят из <a
                href="https://ru.wikipedia.org/wiki/SOLID_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
                target="_blank" rel="nofollow noopener noreferrer">Википедии</a>
        </div>
    </Footer>
</body>

</html>